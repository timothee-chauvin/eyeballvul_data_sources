{"schema_version":"1.7.3","id":"CVE-2025-68375","published":"2025-12-24T10:33:04.819Z","modified":"2025-12-24T22:32:23.351732Z","summary":"perf/x86: Fix NULL event access and potential PEBS record loss","details":"In the Linux kernel, the following vulnerability has been resolved:\n\nperf/x86: Fix NULL event access and potential PEBS record loss\n\nWhen intel_pmu_drain_pebs_icl() is called to drain PEBS records, the\nperf_event_overflow() could be called to process the last PEBS record.\n\nWhile perf_event_overflow() could trigger the interrupt throttle and\nstop all events of the group, like what the below call-chain shows.\n\nperf_event_overflow()\n  -> __perf_event_overflow()\n    ->__perf_event_account_interrupt()\n      -> perf_event_throttle_group()\n        -> perf_event_throttle()\n          -> event->pmu->stop()\n            -> x86_pmu_stop()\n\nThe side effect of stopping the events is that all corresponding event\npointers in cpuc->events[] array are cleared to NULL.\n\nAssume there are two PEBS events (event a and event b) in a group. When\nintel_pmu_drain_pebs_icl() calls perf_event_overflow() to process the\nlast PEBS record of PEBS event a, interrupt throttle is triggered and\nall pointers of event a and event b are cleared to NULL. Then\nintel_pmu_drain_pebs_icl() tries to process the last PEBS record of\nevent b and encounters NULL pointer access.\n\nTo avoid this issue, move cpuc->events[] clearing from x86_pmu_stop()\nto x86_pmu_del(). It's safe since cpuc->active_mask or\ncpuc->pebs_enabled is always checked before access the event pointer\nfrom cpuc->events[].","affected":[{"ranges":[{"type":"GIT","repo":"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git","events":[{"introduced":"9734e25fbf5ae68eb04234b2cd14a4b36ab89141"},{"fixed":"cf69b99805c263117305ac6dffbc85aaf9259d32"},{"fixed":"6b089028bff1f2ff9e0c62b8f1faca1a620e5d6e"},{"fixed":"7e772a93eb61cb6265bdd1c5bde17d0f2718b452"}]}],"versions":["v6.15","v6.15-rc4","v6.15-rc5","v6.15-rc6","v6.15-rc7","v6.16","v6.16-rc1","v6.16-rc2","v6.16-rc3","v6.16-rc4","v6.16-rc5","v6.16-rc6","v6.16-rc7","v6.17","v6.17-rc1","v6.17-rc2","v6.17-rc3","v6.17-rc4","v6.17-rc5","v6.17-rc6","v6.17-rc7","v6.17.1","v6.17.10","v6.17.11","v6.17.12","v6.17.2","v6.17.3","v6.17.4","v6.17.5","v6.17.6","v6.17.7","v6.17.8","v6.17.9","v6.18","v6.18-rc1","v6.18-rc2","v6.18-rc3","v6.18-rc4","v6.18-rc5","v6.18-rc6","v6.18-rc7","v6.18.1"],"database_specific":{"source":"https://storage.googleapis.com/cve-osv-conversion/osv-output/CVE-2025-68375.json"}},{"package":{"name":"Kernel","ecosystem":"Linux"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"6.16.0"},{"fixed":"6.17.13"}]},{"type":"ECOSYSTEM","events":[{"introduced":"6.18.0"},{"fixed":"6.18.2"}]}],"database_specific":{"source":"https://storage.googleapis.com/cve-osv-conversion/osv-output/CVE-2025-68375.json"}}],"references":[{"type":"PACKAGE","url":"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git"},{"type":"WEB","url":"https://git.kernel.org/stable/c/6b089028bff1f2ff9e0c62b8f1faca1a620e5d6e"},{"type":"WEB","url":"https://git.kernel.org/stable/c/7e772a93eb61cb6265bdd1c5bde17d0f2718b452"},{"type":"WEB","url":"https://git.kernel.org/stable/c/cf69b99805c263117305ac6dffbc85aaf9259d32"},{"type":"ADVISORY","url":"https://github.com/CVEProject/cvelistV5/tree/main/cves/2025/68xxx/CVE-2025-68375.json"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2025-68375"}],"database_specific":{"cna_assigner":"Linux","osv_generated_from":"https://github.com/CVEProject/cvelistV5/tree/main/cves/2025/68xxx/CVE-2025-68375.json"}}