{
  "affected": [
    {
      "database_specific": {
        "source": "https://curl.se/docs/CURL-CVE-2021-22901.json"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "7.75.0"
            },
            {
              "fixed": "7.77.0"
            }
          ],
          "type": "SEMVER"
        },
        {
          "events": [
            {
              "introduced": "a304051620b92e12b6b1b4e19edc57b34ea332b6"
            },
            {
              "fixed": "7f4a9a9b2a49547eae24d2e19bc5c346e9026479"
            }
          ],
          "repo": "https://github.com/curl/curl.git",
          "type": "GIT"
        }
      ],
      "versions": [
        "7.76.1",
        "7.76.0",
        "7.75.0"
      ]
    }
  ],
  "aliases": [
    "CVE-2021-22901"
  ],
  "credits": [
    {
      "name": "Harry Sintonen",
      "type": "FINDER"
    },
    {
      "name": "Harry Sintonen",
      "type": "REMEDIATION_DEVELOPER"
    },
    {
      "name": "Daniel Stenberg",
      "type": "REMEDIATION_DEVELOPER"
    },
    {
      "name": "Brad Spencer",
      "type": "OTHER"
    }
  ],
  "database_specific": {
    "CWE": {
      "desc": "Use After Free",
      "id": "CWE-416"
    },
    "URL": "https://curl.se/docs/CVE-2021-22901.json",
    "affects": "both",
    "award": {
      "amount": "2000",
      "currency": "USD"
    },
    "issue": "https://hackerone.com/reports/1180380",
    "last_affected": "7.76.1",
    "package": "curl",
    "severity": "High",
    "www": "https://curl.se/docs/CVE-2021-22901.html"
  },
  "details": "libcurl can be tricked into using already freed memory when a new TLS session\nis negotiated or a client certificate is requested on an existing connection.\nFor example, this can happen when a TLS server requests a client certificate\non a connection that was established without one. A malicious server can use\nthis in rare unfortunate circumstances to potentially reach remote code\nexecution in the client.\n\nOpenSSL can declare a \"new session\" for different reasons, including the\ninitial TLS handshake completion, TLS 1.2 (or earlier) renegotiation, or TLS\n1.3 client certificate requests. When libcurl at runtime sets up support for\nsession ID caching on a connection using OpenSSL, it stores pointers to the\ntransfer in-memory object for later retrieval when OpenSSL considers a new\nsession to be established.\n\nHowever, if the connection is used by multiple transfers (like with a reused\nHTTP/1.1 connection or multiplexed HTTP/2 connection) that first transfer\nobject might be freed before the new session is established on that connection\nand then the function accesses a memory buffer that might be freed. When using\nthat memory, libcurl might even call a function pointer in the object, making\nit possible for a remote code execution if the server could somehow manage to\nget crafted memory content into the correct place in memory.",
  "id": "CURL-CVE-2021-22901",
  "modified": "2024-06-07T13:53:51Z",
  "published": "2021-05-26T08:00:00Z",
  "schema_version": "1.6.0",
  "summary": "TLS session caching disaster"
}