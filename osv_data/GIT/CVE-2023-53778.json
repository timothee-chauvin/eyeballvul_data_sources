{"schema_version":"1.7.3","id":"CVE-2023-53778","published":"2025-12-09T00:00:34.074Z","modified":"2025-12-09T03:27:02.019521Z","summary":"accel/qaic: Clean up integer overflow checking in map_user_pages()","details":"In the Linux kernel, the following vulnerability has been resolved:\n\naccel/qaic: Clean up integer overflow checking in map_user_pages()\n\nThe encode_dma() function has some validation on in_trans->size but it\nwould be more clear to move those checks to find_and_map_user_pages().\n\nThe encode_dma() had two checks:\n\n\tif (in_trans->addr + in_trans->size < in_trans->addr || !in_trans->size)\n\t\treturn -EINVAL;\n\nThe in_trans->addr variable is the starting address.  The in_trans->size\nvariable is the total size of the transfer.  The transfer can occur in\nparts and the resources->xferred_dma_size tracks how many bytes we have\nalready transferred.\n\nThis patch introduces a new variable \"remaining\" which represents the\namount we want to transfer (in_trans->size) minus the amount we have\nalready transferred (resources->xferred_dma_size).\n\nI have modified the check for if in_trans->size is zero to instead check\nif in_trans->size is less than resources->xferred_dma_size.  If we have\nalready transferred more bytes than in_trans->size then there are negative\nbytes remaining which doesn't make sense.  If there are zero bytes\nremaining to be copied, just return success.\n\nThe check in encode_dma() checked that \"addr + size\" could not overflow\nand barring a driver bug that should work, but it's easier to check if\nwe do this in parts.  First check that \"in_trans->addr +\nresources->xferred_dma_size\" is safe.  Then check that \"xfer_start_addr +\nremaining\" is safe.\n\nMy final concern was that we are dealing with u64 values but on 32bit\nsystems the kmalloc() function will truncate the sizes to 32 bits.  So\nI calculated \"total = in_trans->size + offset_in_page(xfer_start_addr);\"\nand returned -EINVAL if it were >= SIZE_MAX.  This will not affect 64bit\nsystems.","affected":[{"ranges":[{"type":"GIT","repo":"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git","events":[{"introduced":"129776ac2e38231fa9c02ce20e116c99de291666"},{"fixed":"d410a96e5cb8c1ec7049c83f2edcd8bbfaf5d9b3"},{"fixed":"96d3c1cadedb6ae2e8965e19cd12caa244afbd9c"}]}],"versions":["v6.3","v6.3-rc5","v6.3-rc6","v6.3-rc7","v6.4","v6.4-rc1","v6.4-rc2","v6.4-rc3","v6.4-rc4","v6.4-rc5","v6.4-rc6","v6.4-rc7","v6.4.1","v6.4.10","v6.4.11","v6.4.2","v6.4.3","v6.4.4","v6.4.5","v6.4.6","v6.4.7","v6.4.8","v6.4.9","v6.5-rc1"],"database_specific":{"source":"https://storage.googleapis.com/cve-osv-conversion/osv-output/CVE-2023-53778.json"}},{"package":{"name":"Kernel","ecosystem":"Linux"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"6.4.0"},{"fixed":"6.4.12"}]}],"database_specific":{"source":"https://storage.googleapis.com/cve-osv-conversion/osv-output/CVE-2023-53778.json"}}],"references":[{"type":"PACKAGE","url":"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git"},{"type":"WEB","url":"https://git.kernel.org/stable/c/96d3c1cadedb6ae2e8965e19cd12caa244afbd9c"},{"type":"WEB","url":"https://git.kernel.org/stable/c/d410a96e5cb8c1ec7049c83f2edcd8bbfaf5d9b3"},{"type":"ADVISORY","url":"https://github.com/CVEProject/cvelistV5/tree/main/cves/2023/53xxx/CVE-2023-53778.json"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2023-53778"}],"database_specific":{"cna_assigner":"Linux","osv_generated_from":"https://github.com/CVEProject/cvelistV5/tree/main/cves/2023/53xxx/CVE-2023-53778.json"}}